# DDPM 의료 영상 디노이징 기술문서

## 목차
1. [개요](#개요)
2. [문제 정의](#문제-정의)
3. [노이즈 유형 분석](#노이즈-유형-분석)
4. [디노이징 기법](#디노이징-기법)
   - [4.1 Z-슬라이스 강도 보정](#41-z-슬라이스-강도-보정)
   - [4.2 적응형 Z-영역 노이즈 제거](#42-적응형-z-영역-노이즈-제거)
   - [4.3 수평 스트라이프 제거](#43-수평-스트라이프-제거)
5. [성능 평가](#성능-평가)
6. [사용 방법](#사용-방법)
7. [파라미터 설정 가이드](#파라미터-설정-가이드)

---

## 개요

본 문서는 DDPM(Denoising Diffusion Probabilistic Models)을 사용한 의료 영상 생성 과정에서 발생하는 아티팩트를 제거하기 위한 통합 디노이징 파이프라인을 설명합니다.

### 개발 배경
- DDPM 기반 초해상도(Super-Resolution) 의료 영상 생성 시 특정 아티팩트 발생
- 뇌 MRI 영상에서 관찰되는 두 가지 주요 노이즈 패턴
- 진단 품질 확보를 위한 자동화된 노이즈 제거 필요성

### 기술 스택
- **언어**: Python 3.x
- **주요 라이브러리**:
  - `nibabel`: NIfTI 의료 영상 포맷 처리
  - `numpy`: 다차원 배열 연산
  - `scipy`: 신호 처리 및 필터링
  - `matplotlib`: 시각화

---

## 문제 정의

### 입력 데이터
- **포맷**: NIfTI (.nii.gz)
- **형상**: 192 × 192 × 192 복셀 (3D 볼륨)
- **데이터 타입**: float32
- **강도 범위**: 정규화된 값 (일반적으로 -1 ~ 1 또는 0 ~ 1)

### 발생하는 노이즈 유형

#### 1. Z-방향 상단 노이즈 존 (DDPM 아티팩트)
- **위치**: Z-축 상위 영역 (약 70-95% 구간)
- **특징**:
  - DDPM 모델의 구조적 한계로 인한 발생
  - 뇌 영역이 고스트처럼 번지는 현상
  - Salt-and-pepper 노이즈 패턴
  - 실제 해부학적 구조가 아닌 생성 아티팩트
- **영향**: 진단 오류 가능성, 시각적 품질 저하

#### 2. 수평 스트라이프 아티팩트
- **위치**: 전체 볼륨에 걸쳐 발생
- **특징**:
  - Sagittal view (시상면)에서 가로 줄무늬로 관찰됨
  - Z-축 방향으로 주기적인 강도 변화
  - FFT 분석 시 고주파 성분으로 나타남
- **영향**: 조직 경계 모호화, 미세 구조 가시성 저하

---

## 노이즈 유형 분석

### 1. Z-축 강도 프로파일 분석

```
분석 방법:
- 각 Z-슬라이스의 평균 강도 계산
- Z-축을 따라 강도 변화 추적
- 이상값(outlier) 감지
```

**주요 발견사항**:
- Z=173, 174, 181-185, 189번 슬라이스에서 급격한 강도 점프 발견
- Z=144 이상 영역에서 전반적인 강도 상승 및 노이즈 증가
- 두개골 끝부분에서 좌-우로 갈수록 노이즈 증가하는 방사형 패턴

### 2. Salt-and-Pepper 노이즈 특성

**특징**:
1. **높은 국소 분산**: 인접 복셀 간 값 차이가 큼
2. **강한 엣지**: 랜덤한 고주파 엣지 생성
3. **낮은 공간 일관성**: 평활화(smoothing) 전후 상관관계 낮음
4. **불규칙한 방사형 프로파일**: 중심에서 가장자리로의 부드러운 감소 없음
5. **균일한 강도 분포**: 히스토그램이 특정 값에 집중되지 않음

### 3. 수평 스트라이프 주파수 분석

**FFT 분석 결과**:
- Z-축 방향 1D FFT에서 고주파 성분이 스트라이프에 대응
- 98th 백분위수 이상의 고주파가 주요 원인
- 저주파 성분은 실제 해부학적 구조를 나타냄 (보존 필요)

---

## 디노이징 기법

### 4.1 Z-슬라이스 강도 보정

#### 목적
Z-축을 따라 발생하는 슬라이스별 강도 이상값을 감지하고 보정하여 일관된 강도 분포를 유지합니다.

#### 알고리즘

```
1. 각 Z-슬라이스의 평균 강도 계산
   z_means[z] = mean(data[:, :, z])

2. Savitzky-Golay 필터 적용 → 부드러운 참조 곡선 생성
   - Window length: 5
   - Polynomial order: 2
   - 이유: 국소적 변화는 포착하되 노이즈는 제거

3. 편차 계산
   deviations[z] = z_means[z] - z_means_smoothed[z]

4. 이상 슬라이스 감지
   anomalous if |deviation[z]| > threshold × std(deviations)
   - 기본 threshold: 2.0 (표준편차의 2배)

5. 이상 슬라이스 보정
   data[:, :, z] *= (z_means_smoothed[z] / z_means[z])
```

#### 수학적 근거

**Savitzky-Golay 필터**:
- 이동 윈도우 내에서 다항식 피팅을 수행하는 평활화 기법
- 장점: 엣지와 피크를 보존하면서 노이즈 제거
- 수식: 각 점에서 주변 점들에 대해 2차 다항식 회귀 수행

**보정 계수**:
```
correction_factor = expected_intensity / observed_intensity
corrected_slice = original_slice × correction_factor
```

#### 효과
- **제거 대상**: 특정 슬라이스의 갑작스러운 강도 변화
- **보존 대상**: 정상적인 해부학적 변화 (예: 회백질 → 백질 전환)
- **결과**: 13-25개의 이상 슬라이스 보정

---

### 4.2 적응형 Z-영역 노이즈 제거

#### 목적
Salt-and-pepper 노이즈로 가득 찬 Z-축 상위 영역을 자동으로 감지하고 제거합니다. 기존의 일률적인 cutoff 방식 대신, 각 슬라이스를 개별적으로 분석하여 보존할 조직과 제거할 노이즈를 구분합니다.

#### 기존 방법의 한계

**일률적 cutoff 방식**:
```
if z > threshold_z:
    data[:, :, z] = 0
```
- 문제점: 두개골 끝부분의 정상 조직도 함께 제거
- 예시: Z=161에서 cutoff → 31개 슬라이스 손실

#### 적응형 분석 알고리즘

```
1. 분석 시작점 설정
   search_start = int(z_dim × 0.70)  # 70% 지점부터
   이유: 뇌 조직은 대부분 하위 70% 내에 위치

2. 각 슬라이스별 노이즈 점수 계산
   for z in range(search_start, z_dim):
       noise_scores[z] = analyze_slice_noise(data[:, :, z])

3. 노이즈 경계 감지
   boundary = first_z where noise_score[z] ≥ threshold
   기본 threshold: 0.35

4. 경계 이후 모든 슬라이스 제거
   data[:, :, boundary:] = 0.0
```

#### 슬라이스 노이즈 분석 메트릭

각 슬라이스에 대해 6가지 메트릭을 계산하여 종합 노이즈 점수를 산출합니다.

##### 메트릭 1: 국소 분산 (Local Variance)
```python
local_var = generic_filter(slice_data, np.var, size=3)
avg_local_var = mean(local_var[foreground_mask])
score1 = min(avg_local_var / 0.01, 1.0)
```
- **원리**: Salt-and-pepper 노이즈는 인접 픽셀 간 값 차이가 큼
- **정상 조직**: 낮은 국소 분산 (smooth transition)
- **노이즈**: 높은 국소 분산 (random fluctuation)
- **가중치**: 0.25

##### 메트릭 2: 엣지 강도 (Edge Strength)
```python
edges = sobel(slice_data)
edge_strength = mean(abs(edges[foreground_mask]))
score2 = min(edge_strength / 0.1, 1.0)
```
- **원리**: 노이즈는 날카롭고 무작위적인 엣지 생성
- **정상 조직**: 부드러운 경계 (낮은 엣지 강도)
- **노이즈**: 강한 무작위 엣지 (높은 엣지 강도)
- **가중치**: 0.20

##### 메트릭 3: 공간 일관성 (Spatial Coherence)
```python
smoothed = gaussian_filter(slice_data, sigma=2)
correlation = corrcoef(slice_data[mask], smoothed[mask])[0, 1]
score3 = 1.0 - max(0, correlation)
```
- **원리**: 정상 조직은 국소적으로 유사한 값을 가짐
- **정상 조직**: 평활화 전후 높은 상관관계 (correlation ≈ 1)
- **노이즈**: 평활화 전후 낮은 상관관계 (무작위 패턴)
- **가중치**: 0.25

##### 메트릭 4: 방사형 프로파일 부드러움 (Radial Profile Smoothness)
```python
# 중심에서 거리별 평균 강도 계산
for radius in range(0, max_r, step):
    ring_mask = (r >= radius) & (r < radius + step)
    radial_profile.append(mean(slice_data[ring_mask]))

# 프로파일 변화율의 표준편차
radial_smoothness = std(diff(radial_profile))
score4 = min(radial_smoothness / 0.05, 1.0)
```
- **원리**: 뇌 조직은 중심에서 가장자리로 부드럽게 감소
- **정상 조직**: 부드러운 방사형 감소 (낮은 변화율)
- **노이즈**: 불규칙한 방사형 패턴 (높은 변화율)
- **가중치**: 0.15

##### 메트릭 5: 강도 분포 균일성 (Intensity Uniformity)
```python
hist, _ = histogram(slice_data[mask], bins=30)
hist_uniformity = std(hist) / (mean(hist) + eps)
score5 = 1.0 - min(hist_uniformity / 2.0, 1.0)
```
- **원리**: 조직은 특정 강도 범위에 집중, 노이즈는 균일 분포
- **정상 조직**: 히스토그램이 특정 값에 피크 (높은 std)
- **노이즈**: 균일한 히스토그램 (낮은 std)
- **가중치**: 0.10

##### 메트릭 6: 채움 비율 (Fill Ratio)
```python
fill_ratio = sum(slice_data > threshold) / total_pixels
score6 = fill_ratio
```
- **원리**: 노이즈는 더 넓은 영역을 채움
- **정상 조직**: 특정 영역만 높은 값 (낮은 채움 비율)
- **노이즈**: 전체적으로 값이 분포 (높은 채움 비율)
- **가중치**: 0.05

##### 종합 노이즈 점수
```python
weights = [0.25, 0.20, 0.25, 0.15, 0.10, 0.05]
noise_score = weighted_average(scores, weights)
# 0.0 = 확실한 조직
# 1.0 = 확실한 노이즈
```

#### 성능 비교

| 방법 | 경계 위치 | 제거 슬라이스 | 보존 슬라이스 | 특징 |
|------|----------|-------------|-------------|------|
| 일률적 cutoff | Z=161 (83.9%) | 31개 | 161개 | 두개골 일부 손실 |
| 적응형 분석 | Z=179 (93.2%) | 13개 | 179개 | **18개 추가 보존** |

**보존된 영역 (Z=161~178) 통계**:
- 평균 강도: 0.0466 (두개골 조직에 해당)
- 일률적 방법: 0.0000 (제거됨)
- 적응형 방법: 0.0466 (보존됨) ✓

---

### 4.3 수평 스트라이프 제거

#### 목적
Z-축 방향으로 발생하는 주기적인 강도 변화 (수평 스트라이프)를 주파수 도메인에서 제거합니다.

#### 알고리즘: FFT 기반 필터링

```
1. 각 (x, y) 위치에서 Z-축 1D 신호 추출
   signal = data[x, y, :]

2. FFT 변환 → 주파수 도메인
   fft_signal = FFT(signal)
   fft_shifted = fftshift(fft_signal)  # 중심에 저주파 배치

3. 주파수 성분 분석
   magnitude = abs(fft_shifted)

4. 저주파 보존 영역 설정
   center = len(fft_shifted) // 2
   preserve_radius = max(5, len(fft_shifted) // 15)
   # 약 6.7%의 중심 저주파 보존

5. 고주파 억제 마스크 생성
   threshold = percentile(magnitude, 98)
   suppress_mask = (magnitude > threshold) & (not in preserve_region)

6. 필터 적용
   fft_shifted[suppress_mask] *= (1.0 - filter_strength)
   # filter_strength = 0.5 → 50% 억제

7. 역변환 → 공간 도메인
   fft_back = ifftshift(fft_shifted)
   filtered_signal = IFFT(fft_back).real
   data[x, y, :] = filtered_signal

8. 반복 (기본 1회)
```

#### 주파수 도메인 필터링 원리

**FFT (Fast Fourier Transform)**:
- 공간 도메인의 신호를 주파수 성분으로 분해
- 수식: `F(k) = Σ f(x) × e^(-2πikx/N)`
- 결과: 각 주파수 성분의 강도와 위상 정보

**스트라이프 = 고주파 성분**:
```
예시:
- 저주파: 전체적인 밝기 변화 (뇌 조직의 자연스러운 변화)
- 고주파: 급격한 변화 (스트라이프, 노이즈)

Z-축 신호:
[0.5, 0.52, 0.48, 0.51, 0.49, ...]  ← 저주파 (보존)
[0.5, 0.9, 0.1, 0.8, 0.2, ...]      ← 고주파 (억제)
```

**억제 강도 선택**:
- **0.85 (85%)**: 너무 강함 → 세로 앨리어싱 발생
- **0.5 (50%)**: 최적 → 스트라이프 제거 + 앨리어싱 없음
- **0.3 (30%)**: 너무 약함 → 스트라이프 잔존

#### 파라미터 튜닝

| 파라미터 | 기본값 | 범위 | 효과 |
|---------|--------|------|------|
| filter_strength | 0.5 | 0.3~0.7 | 높을수록 강하게 제거 (앨리어싱 위험) |
| iterations | 1 | 1~2 | 많을수록 반복 제거 (블러 위험) |
| preserve_radius | len//15 | len//20 ~ len//10 | 클수록 저주파 보존 (디테일 유지) |
| threshold_percentile | 98 | 95~99 | 높을수록 선택적 억제 |

#### 효과 측정

**스트라이프 감소율**:
```python
before_std = std(data)
# ... 필터링 ...
after_std = std(data)
reduction = (1 - after_std / before_std) × 100%
```
- 전형적인 감소율: 60-75%
- 의미: 전체 강도 변동성이 감소 → 스트라이프 제거됨

---

## 성능 평가

### 엣지 보존율 (Edge Preservation)

#### 정의
```python
original_edges = sobel(original_data)
denoised_edges = sobel(denoised_data)

edge_preservation = sum(|denoised_edges|) / sum(|original_edges|) × 100%
```

#### 의미
- **100%**: 모든 엣지 완벽히 보존
- **> 100%**: 새로운 엣지 생성 (과도한 샤프닝)
- **< 100%**: 엣지 손실 (블러)
- **목표**: 99% 이상

#### 방법별 비교

| 방법 | 엣지 보존율 | 비고 |
|------|-----------|------|
| Wavelet (초기) | 71.9% | 심한 블러 ❌ |
| 선형 외삽법 | 100.2% | 과도한 샤프닝 ❌ |
| 최종 통합 | **99.97%** | 최적 ✓ |

### 노이즈 제거 성능

#### Z-영역 노이즈
```
측정: 노이즈 영역의 평균 강도

초기: 0.117 (노이즈 존재)
공격적 방법: 0.0107 (거의 제거)
적응형 방법: 0.0000 (완전 제거) ✓
```

#### 수평 스트라이프
```
측정: 스트라이프 감소율 (표준편차 변화)

초기 시도: 28.1% (불충분)
공격적 FFT: 74.1% (앨리어싱 발생)
최적 FFT: 60-70% (앨리어싱 없음) ✓
```

### 종합 평가 지표

| 지표 | 목표 | 달성 | 상태 |
|-----|------|------|------|
| 엣지 보존 | ≥ 99% | 99.97% | ✓ |
| Z-노이즈 제거 | = 0 | 0.0000 | ✓ |
| 스트라이프 감소 | ≥ 60% | 60-70% | ✓ |
| 두개골 보존 | 최대화 | +18 슬라이스 | ✓ |
| 앨리어싱 발생 | 없음 | 없음 | ✓ |

---

## 사용 방법

### 기본 사용법

```bash
# 기본 실행 (입력: gneo_sample_sr_189.nii.gz)
python3 unified_denoise.py

# 사용자 지정 입력/출력
python3 unified_denoise.py input.nii.gz output.nii.gz
```

### Python 스크립트에서 사용

```python
from unified_denoise import UnifiedDenoiser

# 1. 디노이저 생성
denoiser = UnifiedDenoiser(
    input_path='input.nii.gz',
    output_path='denoised.nii.gz'
)

# 2. 전체 파이프라인 실행
denoised_data, metadata = denoiser.run_full_pipeline()

# 3. 개별 단계 실행 (고급)
# denoiser.correct_z_slice_intensity(detection_threshold=2.0)
# denoiser.adaptive_z_removal(noise_threshold=0.35)
# denoiser.remove_horizontal_stripes(filter_strength=0.5)
# denoiser.save_output()
```

### 출력 파일

실행 후 생성되는 파일들:

1. **{output}_denoised.nii.gz**: 디노이즈된 NIfTI 파일
2. **{output}_metadata.json**: 처리 메타데이터
   ```json
   {
     "input_file": "...",
     "shape": [192, 192, 192],
     "steps": [
       {"step": "z_slice_intensity_correction", ...},
       {"step": "adaptive_z_removal", ...},
       {"step": "horizontal_stripe_removal", ...}
     ],
     "edge_preservation_percent": 99.97
   }
   ```
3. **{output}_comparison.png**: 원본 vs 디노이즈 3뷰 비교
4. **{output}_z_profile.png**: Z-축 강도 프로파일 비교

---

## 파라미터 설정 가이드

### 1. Z-슬라이스 강도 보정

#### `detection_threshold` (기본값: 2.0)
```
범위: 1.0 ~ 3.0
의미: 이상 슬라이스 감지 민감도 (표준편차 배수)

- 낮을수록 (1.5): 더 많은 슬라이스 감지 → 공격적 보정
- 높을수록(2.5): 더 적은 슬라이스 감지 → 보수적 보정

권장:
- 심한 강도 변화: 1.5 ~ 2.0
- 미묘한 변화: 2.0 ~ 2.5
```

#### `smoothing_window` (기본값: 5)
```
범위: 3 ~ 11 (홀수)
의미: Savitzky-Golay 필터 윈도우 크기

- 작을수록 (3): 국소적 변화 포착 → 민감한 감지
- 클수록 (9): 전역적 추세 포착 → 안정적 감지

권장:
- 노이즈가 산발적: 3 ~ 5
- 노이즈가 집중적: 5 ~ 7
```

### 2. 적응형 Z-영역 노이즈 제거

#### `noise_threshold` (기본값: 0.35)
```
범위: 0.2 ~ 0.6
의미: 노이즈 판정 임계값 (0=조직, 1=노이즈)

- 낮을수록 (0.25): 더 많은 슬라이스 제거 → 공격적
- 높을수록 (0.50): 더 적은 슬라이스 제거 → 보수적

권장:
- 두개골 보존 중요: 0.35 ~ 0.45
- 노이즈 완전 제거 필요: 0.25 ~ 0.35

조정 가이드:
- 두개골이 잘린 경우: threshold 증가
- 노이즈가 남은 경우: threshold 감소
```

#### `min_z_start` (기본값: 0.70)
```
범위: 0.60 ~ 0.85
의미: 분석 시작 위치 (전체 Z-축의 백분율)

- 낮을수록 (0.60): 더 넓은 영역 검사 → 보수적
- 높을수록 (0.80): 더 좁은 영역 검사 → 공격적

권장:
- 뇌 크기가 큰 경우: 0.75 ~ 0.85
- 뇌 크기가 작은 경우: 0.60 ~ 0.70
```

### 3. 수평 스트라이프 제거

#### `filter_strength` (기본값: 0.5)
```
범위: 0.3 ~ 0.7
의미: 고주파 억제 강도 (0=없음, 1=완전제거)

- 낮을수록 (0.3): 부드러운 필터링 → 스트라이프 일부 잔존
- 높을수록 (0.7): 강한 필터링 → 앨리어싱 위험

권장:
- 약한 스트라이프: 0.3 ~ 0.4
- 중간 스트라이프: 0.4 ~ 0.5
- 강한 스트라이프: 0.5 ~ 0.6

주의: 0.7 이상 시 세로 방향 앨리어싱 발생 가능
```

#### `iterations` (기본값: 1)
```
범위: 1 ~ 2
의미: 필터링 반복 횟수

- 1회: 적절한 제거 + 디테일 보존
- 2회: 강력한 제거 + 약간의 블러

권장:
- 대부분의 경우: 1회
- 극심한 스트라이프: 2회 (블러 감수)
```

### 파라미터 조합 예시

#### 시나리오 1: 보수적 디노이징 (최대 보존)
```python
denoiser.correct_z_slice_intensity(detection_threshold=2.5)
denoiser.adaptive_z_removal(noise_threshold=0.45, min_z_start=0.75)
denoiser.remove_horizontal_stripes(filter_strength=0.35, iterations=1)
```
- 적용: 중요한 진단 영역 보존 필요
- 효과: 최소 손실, 일부 노이즈 잔존 가능

#### 시나리오 2: 균형 디노이징 (권장)
```python
denoiser.correct_z_slice_intensity(detection_threshold=2.0)
denoiser.adaptive_z_removal(noise_threshold=0.35, min_z_start=0.70)
denoiser.remove_horizontal_stripes(filter_strength=0.5, iterations=1)
```
- 적용: 대부분의 경우
- 효과: 노이즈 제거 + 구조 보존 균형

#### 시나리오 3: 공격적 디노이징 (최대 제거)
```python
denoiser.correct_z_slice_intensity(detection_threshold=1.5)
denoiser.adaptive_z_removal(noise_threshold=0.25, min_z_start=0.65)
denoiser.remove_horizontal_stripes(filter_strength=0.6, iterations=2)
```
- 적용: 시각화 목적, 노이즈가 극심한 경우
- 효과: 최대 노이즈 제거, 일부 디테일 손실 가능

---

## 참고 문헌

### 알고리즘 기반 논문
1. Savitzky, A., & Golay, M. J. (1964). "Smoothing and Differentiation of Data by Simplified Least Squares Procedures." *Analytical Chemistry*
2. Cooley, J. W., & Tukey, J. W. (1965). "An Algorithm for the Machine Calculation of Complex Fourier Series." *Mathematics of Computation*

### 의료 영상 처리
3. Buades, A., Coll, B., & Morel, J. M. (2005). "A Review of Image Denoising Algorithms, with a New One." *Multiscale Modeling & Simulation*
4. Manjón, J. V., et al. (2010). "MRI Denoising Using Non-Local Means." *Medical Image Analysis*

### DDPM 관련
5. Ho, J., Jain, A., & Abbeel, P. (2020). "Denoising Diffusion Probabilistic Models." *NeurIPS*

---

## 버전 히스토리

### v1.0 (2025-11-06)
- 초기 릴리스: 통합 디노이징 파이프라인
- Z-슬라이스 강도 보정 구현
- 적응형 Z-영역 노이즈 제거 구현
- FFT 기반 수평 스트라이프 제거 구현
- 자동화된 메타데이터 및 시각화 생성

---

## 라이선스 및 연락처

**개발**: Claude (Anthropic)
**날짜**: 2025-11-06
**목적**: DDPM 기반 의료 영상 품질 향상

**면책 조항**: 본 소프트웨어는 연구 및 교육 목적으로 제공됩니다. 임상 진단에 사용하기 전에 전문가의 검증이 필요합니다.
